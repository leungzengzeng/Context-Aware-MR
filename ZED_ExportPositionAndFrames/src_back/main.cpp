///////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2017, STEREOLABS.
//
// All rights reserved.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
///////////////////////////////////////////////////////////////////////////


/******************************************************************************************
 ** This sample demonstrates a simple way to use the Spatial Mapping API with the ZED    **
 ** It show the left image and the current mesh generated on a wireframe mode            **
 ** on top of the image                                                                  **
 ** Spatial Mapping can be started and stopped with the Space Bar key                    **
 ******************************************************************************************/
 
 
// Standard includes
#include <stdio.h>    // standard (I/O library)
#include <stdlib.h>   // standard library (set of standard C functions
#include <math.h>     // Math library (Higher math functions )
#include <string.h>
#include <iostream>
#include <fstream>
// OpenGL includes
#include <GL/glew.h>
#include "GL/freeglut.h"

// ZED includes
#include <sl/Camera.hpp>

// Sample includes
#include "GLObject.hpp" // Utils to use GLSL Shader and mesh
#include "utils.hpp"
#include "cuda_gl_interop.h"

using namespace std;
/// ZED object (camera, mesh, pose)
sl::Camera zed; //handle to ZED Camera
sl::Mat left_image; //sl::Mat to handle a image on gpu
sl::Mat zed_image;
sl::Pose pose; //sl::Pose to handle the position of the ZED in world space
sl::Mesh mesh; //sl::Mesh to handle the mesh generated by the spatial mapping 
sl::SpatialMappingParameters spatial_mapping_params;
sl::MeshFilterParameters filter_params;
sl::TRACKING_STATE tracking_state;

// For CUDA-OpenGL interoperability
cudaGraphicsResource* cuda_gl_ressource; //cuda GL resource

// Opengl mesh container
MeshObject* mesh_object = NULL;
sl::float3 mesh_color; //defines the color of the mesh

// Opengl object
Shader* shader_mesh = NULL; //GLSL Shader for mesh
Shader* shader_image = NULL; //GLSL Shader for image
GLuint imageTex; //OpenGL texture mapped with a cuda array (opengl gpu interop)
GLuint shMVPMatrixLoc; //Shader variable loc
GLuint shColorLoc; //Shader variable loc
GLuint texID; //Shader variable loc (sampler/texture)
GLuint fbo = 0; //FBO
GLuint renderedTexture = 0; //Render Texture for FBO
GLuint quad_vb; //buffer for vertices/coords for image

// OpenGL camera projection matrix (inside a sl::Transform)
sl::Transform camera_projection;

// OpenGL Viewport size
int wWnd = 1280;
int hWnd = 720;

// Spatial Mapping status
bool mapping_is_started = false;

//// Sample functions
void close();
void run();

void startMapping();
void stopMapping();

void keyPressedCallback(unsigned char c, int x, int y);
void generateQuadGL();
int initGL();
void drawGL();
void printGL(float x, float y, char *string);
void printHelp();
int frameNumber = 0;
int main(int argc, char** argv) {
    // Init GLUT window
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA);

	// Setup configuration parameters for the ZED    
    sl::InitParameters parameters;
	if (argc > 1) parameters.svo_input_filename = argv[1];
	parameters.camera_resolution = sl::RESOLUTION_HD720;
    parameters.depth_mode = sl::DEPTH_MODE_PERFORMANCE; // Use QUALITY depth mode to improve mapping results
    parameters.coordinate_units = sl::UNIT_METER;
    //parameters.coordinate_system = sl::COORDINATE_SYSTEM_RIGHT_HANDED_Y_UP; // OpenGL coordinates system
	parameters.sdk_verbose = true;
	// Open the ZED
	sl::ERROR_CODE err = zed.open(parameters);
	if (err != sl::ERROR_CODE::SUCCESS) {
		std::cout << sl::errorCode2str(err) << std::endl;
		zed.close();
		return -1;
	}

    wWnd = zed.getResolution().width;
    hWnd = zed.getResolution().height;

    glutInitWindowSize(wWnd, hWnd);
    glutCreateWindow("ZED Spatial Mapping");

	// Configure Spatial Mapping and filtering parameters
    spatial_mapping_params.range_meter.second = sl::SpatialMappingParameters::get(sl::SpatialMappingParameters::RANGE_FAR);
    spatial_mapping_params.resolution_meter = sl::SpatialMappingParameters::get(sl::SpatialMappingParameters::RESOLUTION_LOW);
    spatial_mapping_params.save_texture = false;
    filter_params.set(sl::MeshFilterParameters::FILTER_LOW);
    
    // Initialize OpenGL
    int res = initGL();
    if (res != 0) {
        std::cout << "Failed to initialize OpenGL" << std::endl;
        zed.close();
        return -1;
    }

	printHelp();

    // Create callback function for keyboard event and main loop (display).
    // Then, start the glut main loop.
    glutKeyboardFunc(keyPressedCallback); //callback to handle key events
    glutDisplayFunc(run); //main loop callback
    glutCloseFunc(close); //close callback
    glutMainLoop();
    
    return 0;
}

void startMapping()
{
	// Create Mesh handler for sending the extracted mesh to OpenGL
	mesh.clear();
	if (mesh_object) delete mesh_object;
	mesh_object = new MeshObject(sl::Translation(0, 0, 0), false);

	// Color of wireframe (soft blue)
	mesh_color.r = 0.35;
	mesh_color.g = 0.65;
	mesh_color.b = 0.85;

	// Enable tracking and spatial mapping.
	// Note: spatial mapping needs the motion tracking to operate. Don't forget to enable it as well.
	sl::TrackingParameters trackingParameters;
	trackingParameters.initial_world_transform = sl::Transform::identity();
	trackingParameters.enable_spatial_memory = true;
	zed.enableTracking(trackingParameters);
	zed.enableSpatialMapping(spatial_mapping_params);

	// Launch the first request of the mesh. Other requests will be done when current mesh has been retrieved
	zed.requestMeshAsync();
	mapping_is_started = true;

	// Console information
	std::cout << "** Spatial Mapping is started ... **" << std::endl;
	return;
}

/**
* This function grabs the ZED data and draw the image with the projected mesh.
* This function is called everytime the display needs to be refreshed (50 or 60Hz)
**/
void run(){
	if (zed.grab() == sl::SUCCESS){
		// Retrieve image in GPU and send it to OpenGL
		zed.retrieveImage(left_image, sl::VIEW_LEFT, sl::MEM_GPU);

		// CUDA - OpenGL interop : copy the GPU buffer to a CUDA array mapped to the texture.
		cudaArray_t ArrIm;
		cudaGraphicsMapResources(1, &cuda_gl_ressource, 0);
		cudaGraphicsSubResourceGetMappedArray(&ArrIm, cuda_gl_ressource, 0, 0);
		cudaMemcpy2DToArray(ArrIm, 0, 0, left_image.getPtr<uchar>(sl::MEM_GPU), left_image.getStepBytes(sl::MEM_GPU), left_image.getWidth() * 4, left_image.getHeight(), cudaMemcpyDeviceToDevice);
		cudaGraphicsUnmapResources(1, &cuda_gl_ressource, 0);

		// Get the pose data for future use (projection of the mesh in the current image)
        tracking_state = zed.getPosition(pose);

		// Spatial Mapping mesh request (only if Spatial Mapping is started)
		// Spatial Mapping is started/stopped when space bar is pressed (see keyPressedCallback())
		if (mapping_is_started) {
			// If mesh request status returns true, a new updated mesh is available. If not, then just do nothing : at next grab, we will check again.
			if (zed.getMeshRequestStatusAsync()== sl::SUCCESS) {
				// Get the current mesh generated and send it to opengl
                if (zed.retrieveMeshAsync(mesh) == sl::SUCCESS)
                    mesh_object->updateMesh(mesh);
				// Ask for a new update
				zed.requestMeshAsync();
			}
		}

		zed.retrieveImage(zed_image, sl::VIEW_LEFT);
		cv::Mat cvMat = cv::Mat(zed_image.getHeight(), zed_image.getWidth(), CV_8UC4, zed_image.getPtr<sl::uchar1>(sl::MEM_CPU));

			//cv::imshow("VIEW", cvMat);
			if (tracking_state == sl::TRACKING_STATE_OK)
			{
				// Extract 3x1 rotation from pose
				//sl::Vector3<float> rotation = camera_pose.getRotationVector();
				//rx = rotation.x;
				//ry = rotation.y;
				//rz = rotation.z;
				float tx, ty, tz = 0;
				float rx, ry, rz = 0;
				char text_rotation[256];
				char text_translation[256];

				char output_translation[256];
				char output_rotationMatrix[512];
				sl::Pose pose_inv = sl::Transform::inverse(pose.pose_data);
				// Extract translation from pose
				sl::Vector3<float> translation = pose_inv.getTranslation();
				tx = translation.tx;
				ty = translation.ty;
				tz = translation.tz;

				// Create text file for each frame
				std::string txtFN = "save\\" + std::to_string(frameNumber) + ".txt";
				std::string pngFN = "save\\" + std::to_string(frameNumber) + ".png";

				ofstream outputFile;
				outputFile.open(txtFN);

				if (!outputFile.is_open())
				{
					cout << "ERROR: Can't create txt files. Launch the sample with Administrator rights" << endl;
				}
				else
				{
					// Fill Output Text
					sprintf(output_translation, "%3.2f\n %3.2f\n %3.2f\n", tx, ty, tz);

					// Extract 3x3 rotation from pose
					sl::Rotation rotMat = pose_inv.getRotation();

					sprintf(output_rotationMatrix, "%3.2f %3.2f %3.2f\n%3.2f %3.2f %3.2f\n%3.2f %3.2f %3.2f\n",
						rotMat.r[0], rotMat.r[1], rotMat.r[2],
						rotMat.r[3], rotMat.r[4], rotMat.r[5],
						rotMat.r[6], rotMat.r[7], rotMat.r[8]
						);

					// NOTE: There is more camera info that can be used
					// Unity SDK seems to grab stuff from the left cam usually

					// Grab camera info
					sl::CameraInformation camInfo = zed.getCameraInformation();
					float focal = camInfo.calibration_parameters.left_cam.fy; // ??

					// fov is in degrees
					//float fov = camInfo.calibration_parameters.left_cam.v_fov;

					// Also:
					// From position tracking sample README.MD
					// *NOTE:* Camera tracking is based on 3D vision only.
					// Quick and sudden camera movements can be difficult to track if the image is blurry or there is no visual information in the scene.
					// To improve tracking performance, we recommend using the ZED in HD720 mode at 60fps.


					outputFile << "TVector\n";
					outputFile << output_translation;
					outputFile << "\nRMatrix\n";
					outputFile << output_rotationMatrix;

					// Doesn't look like we actually use this data?
					// todo: what is focal? I have access to focal length x and y. Didn't seem to be used either in VideoCap.cpp

					outputFile << "\nCamera Intrinsics: focal height width";
					outputFile << "\n" << focal << " 720 1280";

					outputFile.close();

					// Write Image To File
					cv::imwrite(pngFN, cvMat);
				}

				// Advance frame number
				frameNumber++;
			}

		////// OpenGL draw call
		// Always draw the mesh even if not updated. Since the camera position changes every frame, the mesh needs to be projected on the image, using the very last camera position 
		drawGL();
	}

    // Check if we are reading an SVO file, and close the window and stop the mapping if we reached the end
    if ( zed.getSVOPosition() > 0 && zed.getSVOPosition() == zed.getSVONumberOfFrames()) {
        glutLeaveMainLoop();
        if (mapping_is_started)
            stopMapping();
    }

	// Get ready for next update
	glutPostRedisplay();
}

void stopMapping(){

	// --> stop the mesh request and extract the whole mesh to filter it and save it as an obj file
	mapping_is_started = false;

	std::cout << "** Stop Spatial Mapping ... **" << std::endl;

	// Extract the whole mesh and filter it
	zed.extractWholeMesh(mesh);
	std::cout << ">> Mesh has been extracted..." << std::endl;

	// Filter the extracted mesh
	mesh.filter(filter_params);
	std::cout << ">> Mesh has been filtered..." << std::endl;

	// If textures have been saved during spatial mapping, apply them to the mesh
	if (spatial_mapping_params.save_texture) {
		mesh.applyTexture();
		std::cout << ">> Mesh has been textured..." << std::endl;
	}

	//Save as an OBJ file
	bool t = mesh.save("save\\mesh",sl::MESH_FILE_PLY);
	if (t) std::cout << ">> Mesh has been saved under \"mesh_gen.obj\" filename" << std::endl;
	else std::cout << ">> Failed to save the mesh under \"mesh_gen.obj\" filename" << std::endl;

	// Disable the spatial mapping module since we don't need it anymore
	zed.disableSpatialMapping();

	return;
}

/**
*  This function close the sample (when a close event is generated)
**/
void close() {
	left_image.free();

	if (shader_mesh) delete shader_mesh; //GLSL Shader for mesh
	if (shader_image) delete shader_image; //GLSL Shader for image
	if (mesh_object) delete mesh_object;

	zed.close();
}

/**
* Utils to generate quads for image texture
**/
void generateQuadGL() {
	// The fullscreen quad's FBO
	static const GLfloat g_quad_vertex_buffer_data[] = {
		-1.0f, -1.0f, 0.0f,
		1.0f, -1.0f, 0.0f,
		-1.0f, 1.0f, 0.0f,
		-1.0f, 1.0f, 0.0f,
		1.0f, -1.0f, 0.0f,
		1.0f, 1.0f, 0.0f};

	//Generate a buffer to handle vertices for the GLSL shader.
	glGenBuffers(1, &quad_vb);
	glBindBuffer(GL_ARRAY_BUFFER, quad_vb);
	glBufferData(GL_ARRAY_BUFFER, sizeof(g_quad_vertex_buffer_data), g_quad_vertex_buffer_data, GL_STATIC_DRAW);
}

/**
* This function initialize OpenGL window and objects
**/
int initGL() {
	//Init glew after window has been created
	glewInit();
	glClearColor(0.0, 0.0, 0.0, 0.0); // When screen cleared, use black.

    // Get Image resolution (depending on InitParameter.camera_resolution or svo resolution)
	int w = zed.getResolution().width;
	int h = zed.getResolution().height;

	//Create and Register OpenGL Texture for Image (RGBA -- 4channels)
	glEnable(GL_TEXTURE_2D);
	glGenTextures(1, &imageTex);
	glBindTexture(GL_TEXTURE_2D, imageTex);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_BGRA_EXT, GL_UNSIGNED_BYTE, NULL);
	glBindTexture(GL_TEXTURE_2D, 0);
	cudaError_t err1 = cudaGraphicsGLRegisterImage(&cuda_gl_ressource, imageTex, GL_TEXTURE_2D, cudaGraphicsMapFlagsNone);
    if (err1 != cudaError::cudaSuccess) return -1;

	//Create GLSL Shaders Mesh and Image
	shader_mesh = new Shader((GLchar*)MESH_VERTEX_SHADER, (GLchar*)MESH_FRAGMENT_SHADER);
	shMVPMatrixLoc = glGetUniformLocation(shader_mesh->getProgramId(), "u_mvpMatrix");
	shColorLoc = glGetUniformLocation(shader_mesh->getProgramId(), "u_color");
	shader_image = new Shader((GLchar*)IMAGE_VERTEX_SHADER, (GLchar*)IMAGE_FRAGMENT_SHADER);
	texID = glGetUniformLocation(shader_image->getProgramId(), "texImage");

	/////////////// Create Frame Buffer for offline rendering //////////////////
	// Here we render the composition of the image and the projection of the mesh on top of it in a texture (using FBO - Frame Buffer Object)
	//
	glGenFramebuffers(1, &fbo);
	glBindFramebuffer(GL_FRAMEBUFFER, fbo);

	// Generate a render texture (which will contain the image and mesh in wireframe overlay)
	glGenTextures(1, &renderedTexture);
	glBindTexture(GL_TEXTURE_2D, renderedTexture);

	// Give an empty image to OpenGL ( the last "0" as pointer )
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, 0);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);

	// Set "renderedTexture" as our color attachment #0
	glFramebufferTexture(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, renderedTexture, 0);

	// Set the list of draw buffers.
	GLenum DrawBuffers[1] = { GL_COLOR_ATTACHMENT0 };
	glDrawBuffers(1, DrawBuffers);

	// Always check that our framebuffer is ok
	if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) {
		std::cout << "invalid FrameBuffer" << std::endl;
		return -1;
	}

	glBindFramebuffer(GL_FRAMEBUFFER, 0);

	///////////// Create Projection Matrix for OpenGL. We will use this matrix in combination with the Pose (on REFERENCE_FRAME_WORLD) to project the mesh on the 2D Image.
	sl::CameraParameters camLeft = zed.getCameraInformation().calibration_parameters.left_cam;
	camera_projection(0, 0) = 1.0f / tanf(camLeft.h_fov * M_PI / 180.f * 0.5f);
	camera_projection(1, 1) = 1.0f / tanf(camLeft.v_fov * M_PI / 180.f * 0.5f);
	float znear = 0.001;
	float zfar = 100.;
	camera_projection(2, 2) = -(zfar + znear) / (zfar - znear);
	camera_projection(2, 3) = -(2.f * zfar * znear) / (zfar - znear);
	camera_projection(3, 2) = -1;
	camera_projection(0, 2) = (camLeft.image_size.width - 2. * camLeft.cx) / camLeft.image_size.width;
	camera_projection(1, 2) = (-1.f * camLeft.image_size.height + 2. * camLeft.cy) / camLeft.image_size.height;
	camera_projection(3, 3) = 0;

	////////////// Generate the Quad for showing the image in a full viewport
	generateQuadGL();

	return 0;
}

/**
* This function draws a text with OpenGL
**/
void printGL(float x, float y, char *string) {
	//set the position of the text in the window using the x and y coordinates
	glRasterPos2f(x, y);
	//get the length of the string to display
	int len = (int)strlen(string);
	//loop to display string
	for (int i = 0; i < len; i++) {
		glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, string[i]);
	}
}

/**
* OpenGL draw function
**/
void drawGL() {
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glEnable(GL_TEXTURE_2D);
	glActiveTexture(GL_TEXTURE0);

	glViewport(0, 0, wWnd, hWnd);

	///// Render Image and wireframe mesh into a texture using the FrameBuffer
	//Bind the framebuffer and specify the viewport (full screen)
	glBindFramebuffer(GL_FRAMEBUFFER, fbo);

	////////// Render the ZED view (Left) in the framebuffer
	glUseProgram(shader_image->getProgramId());
	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_2D, imageTex);
	glUniform1i(texID, 0);
	//invert y axis and color for this image (since its reverted from cuda array)
	glUniform1i(glGetUniformLocation(shader_image->getProgramId(), "revert"), 1);
	glUniform1i(glGetUniformLocation(shader_image->getProgramId(), "rgbflip"), 1);
	
	glEnableVertexAttribArray(0);
	glBindBuffer(GL_ARRAY_BUFFER, quad_vb);
	glVertexAttribPointer(
		0, // attribute 0
		3, // size
		GL_FLOAT, // type
		GL_FALSE, // normalized
		0, // stride
		(void*)0 // array buffer offset
	);

	glDrawArrays(GL_TRIANGLES, 0, 6); // 2*3 indices starting at 0 -> 2 triangles
	glDisableVertexAttribArray(0);
	glUseProgram(0);

    // if the Positional tracking is good, we can draw the mesh over the current image
	if (mesh.triangles.size() && (tracking_state==sl::TRACKING_STATE_OK)) {
		glDisable(GL_TEXTURE_2D);
        // Send the projection and the Pose to the GLSL shader to make the projection of the 2D image.
		sl::Transform vpMatrix = sl::Transform::transpose(camera_projection * sl::Transform::inverse(pose.pose_data));
		glUseProgram(shader_mesh->getProgramId());
		glUniformMatrix4fv(shMVPMatrixLoc, 1, GL_FALSE, vpMatrix.m);
		glUniform3fv(shColorLoc, 1, mesh_color.v);
        // Draw the mesh in GL_TRIANGLES with a polygon mode in line (wire)
		glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
		mesh_object->draw(GL_TRIANGLES);
		glUseProgram(0);
	}

	// Unbind the framebuffer since the texture is now updated.
	glBindFramebuffer(GL_FRAMEBUFFER, 0);

	// Render the texture to the screen
	//Set back the polygon mode
	glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);

	// Use the image shader to show it on the screen.
	glUseProgram(shader_image->getProgramId());
	glBindTexture(GL_TEXTURE_2D, renderedTexture);
	glUniform1i(texID, 0);
	glUniform1i(glGetUniformLocation(shader_image->getProgramId(), "revert"), 0);
	glUniform1i(glGetUniformLocation(shader_image->getProgramId(), "rgbflip"), 0);
	glEnableVertexAttribArray(0);
	glBindBuffer(GL_ARRAY_BUFFER, quad_vb);
	glVertexAttribPointer(0, 3,	GL_FLOAT, GL_FALSE, 0,(void*)0);
	// Draw the triangles
	glDrawArrays(GL_TRIANGLES, 0, 6);
	glDisableVertexAttribArray(0);
	glUseProgram(0);
	glDisable(GL_TEXTURE_2D);

	// show actions
	glColor4f(0.25f, 0.99f, 0.25f, 1.f);
	if (!mapping_is_started)
		printGL(-0.99f, 0.9f, "* Press Space Bar to activate Spatial Mapping.");
	else
		printGL(-0.99f, 0.9f, "* Press Space Bar to stop spatial mapping.");

	// show mapping state
    if ((tracking_state == sl::TRACKING_STATE_OK)) {
        sl::SPATIAL_MAPPING_STATE state = zed.getSpatialMappingState();
        if (state == sl::SPATIAL_MAPPING_STATE_OK || state == sl::SPATIAL_MAPPING_STATE_INITIALIZING) {
            glColor4f(0.25f, 0.99f, 0.25f, 1.f);
            printGL(-0.99f, 0.83f, (char*)(std::string("** ") + sl::spatialMappingState2str(state)).c_str());
        } else if (state == sl::SPATIAL_MAPPING_STATE_NOT_ENABLED) {
            glColor4f(0.55f, 0.65f, 0.55f, 1.f);
            printGL(-0.99f, 0.83f, (char*)(std::string("** ") + sl::spatialMappingState2str(state)).c_str());
        } else {
            glColor4f(0.95f, 0.25f, 0.25f, 1.f);
            printGL(-0.99f, 0.83f, (char*)(std::string("** ") + sl::spatialMappingState2str(state)).c_str());
        }
    } else {
        if (mapping_is_started) {
            glColor4f(0.95f, 0.25f, 0.25f, 1.f);
            printGL(-0.99f, 0.83f, (char*)(std::string("** ") + sl::trackingState2str(tracking_state)).c_str());
        } else {
            glColor4f(0.55f, 0.65f, 0.55f, 1.f);
            printGL(-0.99f, 0.83f, (char*)(std::string("** ") + sl::spatialMappingState2str(sl::SPATIAL_MAPPING_STATE_NOT_ENABLED)).c_str());
        }
    }
	// Swap buffers
	glutSwapBuffers();
}

/**
* This function handles keyboard events (especially space bar to start the mapping)
**/
void keyPressedCallback(unsigned char c, int x, int y) {
	switch (c) {
	case 32: //space bar id	
	    if (!mapping_is_started) // User press the space bar and spatial mapping is not started 
		    startMapping();		
	    else // User press the space bar and spatial mapping is started 
		    stopMapping();	
	break;
	case 'q':
		std::cout << " 'q' has been pressed... Exit" << std::endl;
		glutLeaveMainLoop(); //this will call the close function	
	break;
	default:
        break;
	}
}

/**
* This function displays help in console
**/
void printHelp()
{
	std::cout << "*************************************************************" << std::endl;
	std::cout << "**      Press the Space Bar key to start and stop          **" << std::endl;
	std::cout << "*************************************************************" << std::endl;
}
